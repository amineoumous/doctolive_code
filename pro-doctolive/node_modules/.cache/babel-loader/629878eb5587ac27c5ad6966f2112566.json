{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\app\\\\doctolive_code\\\\pro-doctolive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\app\\\\doctolive_code\\\\pro-doctolive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\app\\\\doctolive_code\\\\pro-doctolive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\app\\\\doctolive_code\\\\pro-doctolive\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar Transport = require(\"../transport\");\n\nvar parseqs = require(\"parseqs\");\n\nvar parser = require(\"engine.io-parser\");\n\nvar yeast = require(\"yeast\");\n\nvar debug = require(\"debug\")(\"engine.io-client:polling\");\n\nvar Polling = /*#__PURE__*/function (_Transport) {\n  \"use strict\";\n\n  _inherits(Polling, _Transport);\n\n  var _super = _createSuper(Polling);\n\n  function Polling() {\n    _classCallCheck(this, Polling);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Polling, [{\n    key: \"name\",\n    get:\n    /**\r\n     * Transport name.\r\n     */\n    function get() {\n      return \"polling\";\n    }\n    /**\r\n     * Opens the socket (triggers polling). We write a PING message to determine\r\n     * when the transport is open.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"doOpen\",\n    value: function doOpen() {\n      this.poll();\n    }\n    /**\r\n     * Pauses polling.\r\n     *\r\n     * @param {Function} callback upon buffers are flushed and transport is paused\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(onPause) {\n      var self = this;\n      this.readyState = \"pausing\";\n\n      function pause() {\n        debug(\"paused\");\n        self.readyState = \"paused\";\n        onPause();\n      }\n\n      if (this.polling || !this.writable) {\n        var total = 0;\n\n        if (this.polling) {\n          debug(\"we are currently polling - waiting to pause\");\n          total++;\n          this.once(\"pollComplete\", function () {\n            debug(\"pre-pause polling complete\");\n            --total || pause();\n          });\n        }\n\n        if (!this.writable) {\n          debug(\"we are currently writing - waiting to pause\");\n          total++;\n          this.once(\"drain\", function () {\n            debug(\"pre-pause writing complete\");\n            --total || pause();\n          });\n        }\n      } else {\n        pause();\n      }\n    }\n    /**\r\n     * Starts polling cycle.\r\n     *\r\n     * @api public\r\n     */\n\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      debug(\"polling\");\n      this.polling = true;\n      this.doPoll();\n      this.emit(\"poll\");\n    }\n    /**\r\n     * Overloads onData to detect payloads.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"onData\",\n    value: function onData(data) {\n      var self = this;\n      debug(\"polling got data %s\", data);\n\n      var callback = function callback(packet, index, total) {\n        // if its the first message we consider the transport open\n        if (\"opening\" === self.readyState && packet.type === \"open\") {\n          self.onOpen();\n        } // if its a close packet, we close the ongoing requests\n\n\n        if (\"close\" === packet.type) {\n          self.onClose();\n          return false;\n        } // otherwise bypass onData and handle the message\n\n\n        self.onPacket(packet);\n      }; // decode payload\n\n\n      parser.decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing\n\n      if (\"closed\" !== this.readyState) {\n        // if we got data we're not polling\n        this.polling = false;\n        this.emit(\"pollComplete\");\n\n        if (\"open\" === this.readyState) {\n          this.poll();\n        } else {\n          debug('ignoring poll - transport state \"%s\"', this.readyState);\n        }\n      }\n    }\n    /**\r\n     * For polling, send a close packet.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"doClose\",\n    value: function doClose() {\n      var self = this;\n\n      function close() {\n        debug(\"writing close packet\");\n        self.write([{\n          type: \"close\"\n        }]);\n      }\n\n      if (\"open\" === this.readyState) {\n        debug(\"transport open - closing\");\n        close();\n      } else {\n        // in case we're trying to close while\n        // handshaking is in progress (GH-164)\n        debug(\"transport not open - deferring close\");\n        this.once(\"open\", close);\n      }\n    }\n    /**\r\n     * Writes a packets payload.\r\n     *\r\n     * @param {Array} data packets\r\n     * @param {Function} drain callback\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(packets) {\n      var _this = this;\n\n      this.writable = false;\n      parser.encodePayload(packets, function (data) {\n        _this.doWrite(data, function () {\n          _this.writable = true;\n\n          _this.emit(\"drain\");\n        });\n      });\n    }\n    /**\r\n     * Generates uri for connection.\r\n     *\r\n     * @api private\r\n     */\n\n  }, {\n    key: \"uri\",\n    value: function uri() {\n      var query = this.query || {};\n      var schema = this.opts.secure ? \"https\" : \"http\";\n      var port = \"\"; // cache busting is forced\n\n      if (false !== this.opts.timestampRequests) {\n        query[this.opts.timestampParam] = yeast();\n      }\n\n      if (!this.supportsBinary && !query.sid) {\n        query.b64 = 1;\n      }\n\n      query = parseqs.encode(query); // avoid port if default for schema\n\n      if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n        port = \":\" + this.opts.port;\n      } // prepend ? to query\n\n\n      if (query.length) {\n        query = \"?\" + query;\n      }\n\n      var ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n      return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + query;\n    }\n  }]);\n\n  return Polling;\n}(Transport);\n\nmodule.exports = Polling;","map":{"version":3,"names":["Transport","require","parseqs","parser","yeast","debug","Polling","poll","onPause","self","readyState","pause","polling","writable","total","once","doPoll","emit","data","callback","packet","index","type","onOpen","onClose","onPacket","decodePayload","socket","binaryType","forEach","close","write","packets","encodePayload","doWrite","query","schema","opts","secure","port","timestampRequests","timestampParam","supportsBinary","sid","b64","encode","Number","length","ipv6","hostname","indexOf","path","module","exports"],"sources":["C:/app/doctolive_code/pro-doctolive/node_modules/engine.io-client/lib/transports/polling.js"],"sourcesContent":["const Transport = require(\"../transport\");\r\nconst parseqs = require(\"parseqs\");\r\nconst parser = require(\"engine.io-parser\");\r\nconst yeast = require(\"yeast\");\r\n\r\nconst debug = require(\"debug\")(\"engine.io-client:polling\");\r\n\r\nclass Polling extends Transport {\r\n  /**\r\n   * Transport name.\r\n   */\r\n  get name() {\r\n    return \"polling\";\r\n  }\r\n\r\n  /**\r\n   * Opens the socket (triggers polling). We write a PING message to determine\r\n   * when the transport is open.\r\n   *\r\n   * @api private\r\n   */\r\n  doOpen() {\r\n    this.poll();\r\n  }\r\n\r\n  /**\r\n   * Pauses polling.\r\n   *\r\n   * @param {Function} callback upon buffers are flushed and transport is paused\r\n   * @api private\r\n   */\r\n  pause(onPause) {\r\n    const self = this;\r\n\r\n    this.readyState = \"pausing\";\r\n\r\n    function pause() {\r\n      debug(\"paused\");\r\n      self.readyState = \"paused\";\r\n      onPause();\r\n    }\r\n\r\n    if (this.polling || !this.writable) {\r\n      let total = 0;\r\n\r\n      if (this.polling) {\r\n        debug(\"we are currently polling - waiting to pause\");\r\n        total++;\r\n        this.once(\"pollComplete\", function() {\r\n          debug(\"pre-pause polling complete\");\r\n          --total || pause();\r\n        });\r\n      }\r\n\r\n      if (!this.writable) {\r\n        debug(\"we are currently writing - waiting to pause\");\r\n        total++;\r\n        this.once(\"drain\", function() {\r\n          debug(\"pre-pause writing complete\");\r\n          --total || pause();\r\n        });\r\n      }\r\n    } else {\r\n      pause();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts polling cycle.\r\n   *\r\n   * @api public\r\n   */\r\n  poll() {\r\n    debug(\"polling\");\r\n    this.polling = true;\r\n    this.doPoll();\r\n    this.emit(\"poll\");\r\n  }\r\n\r\n  /**\r\n   * Overloads onData to detect payloads.\r\n   *\r\n   * @api private\r\n   */\r\n  onData(data) {\r\n    const self = this;\r\n    debug(\"polling got data %s\", data);\r\n    const callback = function(packet, index, total) {\r\n      // if its the first message we consider the transport open\r\n      if (\"opening\" === self.readyState && packet.type === \"open\") {\r\n        self.onOpen();\r\n      }\r\n\r\n      // if its a close packet, we close the ongoing requests\r\n      if (\"close\" === packet.type) {\r\n        self.onClose();\r\n        return false;\r\n      }\r\n\r\n      // otherwise bypass onData and handle the message\r\n      self.onPacket(packet);\r\n    };\r\n\r\n    // decode payload\r\n    parser.decodePayload(data, this.socket.binaryType).forEach(callback);\r\n\r\n    // if an event did not trigger closing\r\n    if (\"closed\" !== this.readyState) {\r\n      // if we got data we're not polling\r\n      this.polling = false;\r\n      this.emit(\"pollComplete\");\r\n\r\n      if (\"open\" === this.readyState) {\r\n        this.poll();\r\n      } else {\r\n        debug('ignoring poll - transport state \"%s\"', this.readyState);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For polling, send a close packet.\r\n   *\r\n   * @api private\r\n   */\r\n  doClose() {\r\n    const self = this;\r\n\r\n    function close() {\r\n      debug(\"writing close packet\");\r\n      self.write([{ type: \"close\" }]);\r\n    }\r\n\r\n    if (\"open\" === this.readyState) {\r\n      debug(\"transport open - closing\");\r\n      close();\r\n    } else {\r\n      // in case we're trying to close while\r\n      // handshaking is in progress (GH-164)\r\n      debug(\"transport not open - deferring close\");\r\n      this.once(\"open\", close);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a packets payload.\r\n   *\r\n   * @param {Array} data packets\r\n   * @param {Function} drain callback\r\n   * @api private\r\n   */\r\n  write(packets) {\r\n    this.writable = false;\r\n\r\n    parser.encodePayload(packets, data => {\r\n      this.doWrite(data, () => {\r\n        this.writable = true;\r\n        this.emit(\"drain\");\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates uri for connection.\r\n   *\r\n   * @api private\r\n   */\r\n  uri() {\r\n    let query = this.query || {};\r\n    const schema = this.opts.secure ? \"https\" : \"http\";\r\n    let port = \"\";\r\n\r\n    // cache busting is forced\r\n    if (false !== this.opts.timestampRequests) {\r\n      query[this.opts.timestampParam] = yeast();\r\n    }\r\n\r\n    if (!this.supportsBinary && !query.sid) {\r\n      query.b64 = 1;\r\n    }\r\n\r\n    query = parseqs.encode(query);\r\n\r\n    // avoid port if default for schema\r\n    if (\r\n      this.opts.port &&\r\n      ((\"https\" === schema && Number(this.opts.port) !== 443) ||\r\n        (\"http\" === schema && Number(this.opts.port) !== 80))\r\n    ) {\r\n      port = \":\" + this.opts.port;\r\n    }\r\n\r\n    // prepend ? to query\r\n    if (query.length) {\r\n      query = \"?\" + query;\r\n    }\r\n\r\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\r\n    return (\r\n      schema +\r\n      \"://\" +\r\n      (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\r\n      port +\r\n      this.opts.path +\r\n      query\r\n    );\r\n  }\r\n}\r\n\r\nmodule.exports = Polling;\r\n"],"mappings":";;;;;;;;AAAA,IAAMA,SAAS,GAAGC,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,kBAAD,CAAtB;;AACA,IAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AAEA,IAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAAP,CAAiB,0BAAjB,CAAd;;IAEMK,O;;;;;;;;;;;;;;;;IACJ;AACF;AACA;IACE,eAAW;MACT,OAAO,SAAP;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kBAAS;MACP,KAAKC,IAAL;IACD;IAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,eAAMC,OAAN,EAAe;MACb,IAAMC,IAAI,GAAG,IAAb;MAEA,KAAKC,UAAL,GAAkB,SAAlB;;MAEA,SAASC,KAAT,GAAiB;QACfN,KAAK,CAAC,QAAD,CAAL;QACAI,IAAI,CAACC,UAAL,GAAkB,QAAlB;QACAF,OAAO;MACR;;MAED,IAAI,KAAKI,OAAL,IAAgB,CAAC,KAAKC,QAA1B,EAAoC;QAClC,IAAIC,KAAK,GAAG,CAAZ;;QAEA,IAAI,KAAKF,OAAT,EAAkB;UAChBP,KAAK,CAAC,6CAAD,CAAL;UACAS,KAAK;UACL,KAAKC,IAAL,CAAU,cAAV,EAA0B,YAAW;YACnCV,KAAK,CAAC,4BAAD,CAAL;YACA,EAAES,KAAF,IAAWH,KAAK,EAAhB;UACD,CAHD;QAID;;QAED,IAAI,CAAC,KAAKE,QAAV,EAAoB;UAClBR,KAAK,CAAC,6CAAD,CAAL;UACAS,KAAK;UACL,KAAKC,IAAL,CAAU,OAAV,EAAmB,YAAW;YAC5BV,KAAK,CAAC,4BAAD,CAAL;YACA,EAAES,KAAF,IAAWH,KAAK,EAAhB;UACD,CAHD;QAID;MACF,CApBD,MAoBO;QACLA,KAAK;MACN;IACF;IAED;AACF;AACA;AACA;AACA;;;;WACE,gBAAO;MACLN,KAAK,CAAC,SAAD,CAAL;MACA,KAAKO,OAAL,GAAe,IAAf;MACA,KAAKI,MAAL;MACA,KAAKC,IAAL,CAAU,MAAV;IACD;IAED;AACF;AACA;AACA;AACA;;;;WACE,gBAAOC,IAAP,EAAa;MACX,IAAMT,IAAI,GAAG,IAAb;MACAJ,KAAK,CAAC,qBAAD,EAAwBa,IAAxB,CAAL;;MACA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAASC,MAAT,EAAiBC,KAAjB,EAAwBP,KAAxB,EAA+B;QAC9C;QACA,IAAI,cAAcL,IAAI,CAACC,UAAnB,IAAiCU,MAAM,CAACE,IAAP,KAAgB,MAArD,EAA6D;UAC3Db,IAAI,CAACc,MAAL;QACD,CAJ6C,CAM9C;;;QACA,IAAI,YAAYH,MAAM,CAACE,IAAvB,EAA6B;UAC3Bb,IAAI,CAACe,OAAL;UACA,OAAO,KAAP;QACD,CAV6C,CAY9C;;;QACAf,IAAI,CAACgB,QAAL,CAAcL,MAAd;MACD,CAdD,CAHW,CAmBX;;;MACAjB,MAAM,CAACuB,aAAP,CAAqBR,IAArB,EAA2B,KAAKS,MAAL,CAAYC,UAAvC,EAAmDC,OAAnD,CAA2DV,QAA3D,EApBW,CAsBX;;MACA,IAAI,aAAa,KAAKT,UAAtB,EAAkC;QAChC;QACA,KAAKE,OAAL,GAAe,KAAf;QACA,KAAKK,IAAL,CAAU,cAAV;;QAEA,IAAI,WAAW,KAAKP,UAApB,EAAgC;UAC9B,KAAKH,IAAL;QACD,CAFD,MAEO;UACLF,KAAK,CAAC,sCAAD,EAAyC,KAAKK,UAA9C,CAAL;QACD;MACF;IACF;IAED;AACF;AACA;AACA;AACA;;;;WACE,mBAAU;MACR,IAAMD,IAAI,GAAG,IAAb;;MAEA,SAASqB,KAAT,GAAiB;QACfzB,KAAK,CAAC,sBAAD,CAAL;QACAI,IAAI,CAACsB,KAAL,CAAW,CAAC;UAAET,IAAI,EAAE;QAAR,CAAD,CAAX;MACD;;MAED,IAAI,WAAW,KAAKZ,UAApB,EAAgC;QAC9BL,KAAK,CAAC,0BAAD,CAAL;QACAyB,KAAK;MACN,CAHD,MAGO;QACL;QACA;QACAzB,KAAK,CAAC,sCAAD,CAAL;QACA,KAAKU,IAAL,CAAU,MAAV,EAAkBe,KAAlB;MACD;IACF;IAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,eAAME,OAAN,EAAe;MAAA;;MACb,KAAKnB,QAAL,GAAgB,KAAhB;MAEAV,MAAM,CAAC8B,aAAP,CAAqBD,OAArB,EAA8B,UAAAd,IAAI,EAAI;QACpC,KAAI,CAACgB,OAAL,CAAahB,IAAb,EAAmB,YAAM;UACvB,KAAI,CAACL,QAAL,GAAgB,IAAhB;;UACA,KAAI,CAACI,IAAL,CAAU,OAAV;QACD,CAHD;MAID,CALD;IAMD;IAED;AACF;AACA;AACA;AACA;;;;WACE,eAAM;MACJ,IAAIkB,KAAK,GAAG,KAAKA,KAAL,IAAc,EAA1B;MACA,IAAMC,MAAM,GAAG,KAAKC,IAAL,CAAUC,MAAV,GAAmB,OAAnB,GAA6B,MAA5C;MACA,IAAIC,IAAI,GAAG,EAAX,CAHI,CAKJ;;MACA,IAAI,UAAU,KAAKF,IAAL,CAAUG,iBAAxB,EAA2C;QACzCL,KAAK,CAAC,KAAKE,IAAL,CAAUI,cAAX,CAAL,GAAkCrC,KAAK,EAAvC;MACD;;MAED,IAAI,CAAC,KAAKsC,cAAN,IAAwB,CAACP,KAAK,CAACQ,GAAnC,EAAwC;QACtCR,KAAK,CAACS,GAAN,GAAY,CAAZ;MACD;;MAEDT,KAAK,GAAGjC,OAAO,CAAC2C,MAAR,CAAeV,KAAf,CAAR,CAdI,CAgBJ;;MACA,IACE,KAAKE,IAAL,CAAUE,IAAV,KACE,YAAYH,MAAZ,IAAsBU,MAAM,CAAC,KAAKT,IAAL,CAAUE,IAAX,CAAN,KAA2B,GAAlD,IACE,WAAWH,MAAX,IAAqBU,MAAM,CAAC,KAAKT,IAAL,CAAUE,IAAX,CAAN,KAA2B,EAFnD,CADF,EAIE;QACAA,IAAI,GAAG,MAAM,KAAKF,IAAL,CAAUE,IAAvB;MACD,CAvBG,CAyBJ;;;MACA,IAAIJ,KAAK,CAACY,MAAV,EAAkB;QAChBZ,KAAK,GAAG,MAAMA,KAAd;MACD;;MAED,IAAMa,IAAI,GAAG,KAAKX,IAAL,CAAUY,QAAV,CAAmBC,OAAnB,CAA2B,GAA3B,MAAoC,CAAC,CAAlD;MACA,OACEd,MAAM,GACN,KADA,IAECY,IAAI,GAAG,MAAM,KAAKX,IAAL,CAAUY,QAAhB,GAA2B,GAA9B,GAAoC,KAAKZ,IAAL,CAAUY,QAFnD,IAGAV,IAHA,GAIA,KAAKF,IAAL,CAAUc,IAJV,GAKAhB,KANF;IAQD;;;;EAvMmBnC,S;;AA0MtBoD,MAAM,CAACC,OAAP,GAAiB/C,OAAjB"},"metadata":{},"sourceType":"script"}